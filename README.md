### 1. 문제 정의
- 하노이 탑은 3개의 기둥과 여러 개의 원판으로 구성됩니다.
- 목표: 모든 원판을 시작 기둥에서 목표 기둥으로 옮기되, 다음 규칙을 따릅니다:
  1. 한 번에 한 개의 원판만 이동 가능.
  2. 큰 원판은 작은 원판 위에 올릴 수 없다.
  3. 중간 기둥을 보조 기둥으로 사용할 수 있다.

### 2. 함수형 프로그래밍 접근
함수형 프로그래밍의 특징을 활용하기 위해 상태를 변경하지 않고 재귀적으로 문제를 해결합니다.

---

### 3. 계획

#### 3.1 함수 설계
1. **기본 함수: `hanoi(n, source, target, auxiliary)`**
   - `n`: 이동해야 할 원판의 수.
   - `source`: 현재 원판이 위치한 시작 기둥.
   - `target`: 원판을 이동시킬 목표 기둥.
   - `auxiliary`: 임시로 사용할 보조 기둥.

#### 3.2 재귀적 접근
1. **기저 조건**:
   - `n == 1`: 원판이 하나일 경우, `source`에서 `target`으로 이동.
2. **재귀 조건**:
   - `n > 1`일 경우, 다음 순서로 작업을 수행:
     1. `n-1`개의 원판을 `source`에서 `auxiliary`로 이동 (`target`을 보조 기둥으로 사용).
     2. 가장 큰 원판을 `source`에서 `target`으로 이동.
     3. `n-1`개의 원판을 `auxiliary`에서 `target`으로 이동 (`source`를 보조 기둥으로 사용).

---

### 4. 동작 순서
- **예시**: 원판 3개 (`n=3`, `source=A`, `target=C`, `auxiliary=B`)
  1. `n=2`인 하위 문제로 분할:
     - 2개의 원판을 `A`에서 `B`로 이동 (`C` 사용).
  2. 가장 큰 원판(3번 원판)을 `A`에서 `C`로 이동.
  3. `n=2`인 하위 문제로 분할:
     - 2개의 원판을 `B`에서 `C`로 이동 (`A` 사용).

---

### 5. 함수 호출의 흐름
- `hanoi(3, A, C, B)` → 분할:
  - `hanoi(2, A, B, C)` → 다시 분할:
    - `hanoi(1, A, C, B)` (기저 조건)
  - Move 3번 원판.
  - `hanoi(2, B, C, A)` → 다시 분할:
    - `hanoi(1, B, A, C)` (기저 조건)

---

### 6. 함수형 프로그래밍의 이점
1. **재귀를 통한 간결함**: 하위 문제로 분할하는 재귀적 접근은 상태 변경 없이 명확한 흐름을 유지.
2. **부작용 없음**: 함수는 입력값에 따라 동일한 출력값을 생성하므로 프로그램의 동작이 예측 가능.
3. **분할 정복**: 큰 문제를 작은 문제로 나눠 해결하여 효율적.

